#!/usr/bin/env python3
'''

	Celsus - Scientific reference manager for those with puristic taste.

	TODO: Rework the whole code, put stuff in function so that bibtex can be revised if required.
	Worst case do an automatic remove and readd, this might work.
	add short versions of --open and similar.

'''

# Parse arguments
import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument('--description', action='store_true')
# Add the command subparser
subparsers = parser.add_subparsers(dest='command')
# use
parser_use = subparsers.add_parser(
	'use',
	help='Initialise a new repository or activate an existing one.'
)
parser_use.add_argument(
	'path',
	metavar='PATH',
	type=str,
	default='.',
	help='to the repository.'
)
# add
parser_add = subparsers.add_parser(
	'add',
	help='a pdf with corresponding unique key (DOI, arXiv ID, ...) to the repository.'
)
parser_add.add_argument(
	'--from',
	type=str,
	help=(
		'Directory from which to add *.pdf files recursively.'
		+ ' Positional arguments are ignored if set.'
	),
	dest='from_dir'
)
parser_add.add_argument(
	'refs',
	metavar='REFS',
	nargs='*',
	type=str,
	help=(
	'List similar to [file1 key1 [file2 key2 ...]]. '
	'If file is \'-\', it must be an arXiv paper which will be downloaded automatically. '
	'If key is \'-\', celsus will try to get the key from the file. '
	'Consequently, file must not be \'-\' in this case.'
	)
)
# list
parser_list = subparsers.add_parser(
	'list',
	help='matching references, see flags.'
)
parser_list.add_argument(
	'keywords',
	metavar='KEYWORDS',
	nargs='*',
	type=str,
	help='List of keywords which must all be present '
	'in a matching bibtex entry (case sensitive).'
)
parser_list.add_argument('--key', action='store_true', help='Print the key.')
parser_list.add_argument(
	'--file',
	action='store_true',
	help='Print the path to the reference\'s pdf file.'
)
parser_list.add_argument('--nobib', action='store_true', help='Don\'t print the bibtex entry.')
parser_list.add_argument(
	'--open',
	'-o',
	action='store_true',
	help='Open the pdfs.'
)
parser_list.add_argument(
	'--deep',
	action='store_true',
	help='Additionally search the text contents of the pdfs. '
	'It will enter interactive mode. '
	'The intended use is to review matching references and add them to a list. '
	'This list can then be written to file or stdout.'
	'From any such file, the corresponding pdfs can be opened using '
	'`celsus list --open --include=FILENAME KEYWORDS`.'
)
parser_list.add_argument(
	'--include',
	nargs='+',
	type=str,
	metavar='FILENAME',
	help='Only consider references listed in this file '
	'(newline separated keys, e.g. DOIs or arXiv IDs).'
)
parser_list.add_argument(
	'--exclude',
	nargs='+',
	type=str,
	metavar='FILENAME',
	help='Analogue to --include, but listed references are not considered '
	'even if present in --include.'
)

# 
# remove
parser_remove = subparsers.add_parser(
	'remove',
	help='references from the repository.',
	description='Can be used to conveniently delete a limited number of references, '
	'e.g. due to duplication or because a newer version is available. '
	'For mass-deletion or moving to another celsus repository, use alike '
	'`celsus list --nobib --file | xargs -n1 -I{} sh -c \'rm {} && rm {}.celsus\'`.'
)
parser_remove.add_argument(
	'keys',
	metavar='KEYS',
	nargs='+',
	type=str,
	help='Celsus keys of the entries that are to be deleted.'
)
parser_remove.add_argument(
	'--noopen',
	action='store_true',
	help='Do not open the viewer to inspect pdfs which are to be deleted.'
)
parser_remove.add_argument(
	'--move',
	action='store_true',
	help='Move files into current working directory instead of removing them. '
	'This will overwrite files with the same name in the working directory.'
)
# config
parser_config = subparsers.add_parser('config')
parser_config.add_argument(
	'--editor',
	type=str,
	help='Command to open the preferred editor, e.g. vi or nano.'
)
parser_config.add_argument(
	'--viewer',
	type=str,
	help='Command for opening pdfs, e.g. evince.'
)
# Parse
args = parser.parse_args()
if args.command is None or parser.description:
	parser.print_help()
	if args.description:
		print(
			'\n--------------------\n\nReference manager\n\n'
			'Uses unique keys to store scientific references in a database.\n'
			'Keys can be DOIs, arXiv IDs (without the arXiv: prefix!) or manually determined.\n'
			'The bibtex citation is automatically loaded from doi.org, arxiv.org or can be added manually.\n'
			'Files are copied into the repository and renamed consistently to\n\n'
			'<root>/<year>/<author><year>.<suffix>\n\n'
			'Citation keys are automatically generated to <author><year>.\n'
			'Both the citation key and the filename are augmented with \n'
			'lower case letters if multiple references lead to the same key.\n'
			'The user-specific config file is ~/.celsusconfig.\n'
		)
	#
	exit(1)
#


# Imports
import os
import shutil
import tempfile
import requests
import readline
import celsus
from celsus.utils import (
	get_config,
	write_config,
	get_active_repository,
	ONLY_KEY, BIB, BIB_AND_CONTENT,
	write_celsus_file,
	open_viewer, open_editor,
	get_text, find_key
)
from celsus.bibtex import (
	parse,
	doi2bib, arxiv2bib,
	is_doi, is_arxiv,
	empty_bib_article,
	empty_bib_article_ismrm,
	gen_letters
)
from celsus.latex import is_non_ascii, unicode_to_latex


# Helper functions
is_alive = lambda process: process is not None and process.poll() is None
clear_screen = lambda: print('\033[2J\033[H')

def edit_bibtex_manually(bib, key):
	if len(bib) == 0:
		if key.lower().find("ismrm") >= 0: bib = empty_bib_article_ismrm 
		else: bib = empty_bib_article
	#
	# Open file and editor
	handle, tmppath = tempfile.mkstemp()
	with open(handle, 'w') as f:
		f.write(bib)
	#
	proc = open_editor(tmppath, config)
	if proc.returncode != 0:
		raise Exception('Editor could not be opened successfully.', file=stderr)
	#
	# Get file contents and remove
	with open(tmppath, 'r') as f:
		bib = f.read().strip()
	#
	os.remove(tmppath)
	return bib
#

def finalise_citation(bib):
	# Parse
	old_citation_key, author, year = parse(bib)
	# Everything found?
	if any(v is None for v in (author, year, old_citation_key)): return False
	# Add letter(s) if citation key is already occupied
	target_dir = os.path.join(path, year)
	found = False
	extension = os.path.splitext(filepath)[1].lower()
	for letter in gen_letters():
		citation_key = author + year + letter
		target_filename = os.path.join(target_dir, citation_key + extension)
		if not os.path.exists(target_filename):
			found = True
			break
		#
	#
	# Modify bib to include citation key
	if isinstance(old_citation_key, str):
		bib = bib.replace(old_citation_key, citation_key, 1)
	#
	else: # In this case the key is integer, indicating where the key should be
		bib = bib[:old_citation_key] + citation_key + bib[old_citation_key:]
	#
	return bib, target_dir, target_filename
#

def add_article_recur_A(key, filepath, file_exists, text, repository, config):
	"""
		Gets the key and a function to get the bib
		then calls stage 2
	"""
	global viewer_proc
	# Check key
	key = key.lower()
	if key == '-':
		key_is_valid = True
		get_bib = None
	#
	elif is_doi(key):
		key_is_valid = True
		get_bib = lambda key: (doi2bib(key), '')
	#
	elif is_arxiv(key):
		key_is_valid = True
		get_bib = lambda key: arxiv2bib(key)
	#
	else:
		key_is_valid = False
		get_bib = None
	#
	if get_bib is None:
		# Open viewer
		if not is_alive(viewer_proc) and file_exists:
			viewer_proc = open_viewer(filepath, config)
		#
		# Distinguish what went wrong
		if key_is_valid:
			if not file_exists:
				print('File {} doesn\'t exist'.format(filepath))
				return False
			#
			if not len(text): text = get_text(filepath)
			key = find_key(text)
			if len(key) == 0:
				key = input(
					'Could not identify key of {}, please find it manually (Key=..., Skip): '.format(filepath)
				).strip()
			#
		#
		else:
			ui = input('Key is no DOI or arXiv ID, enter another key? (Yes=y, User defined key=n, Skip) ')
			if ui == 'y':
				key == input('Enter a new key: ')
			elif ui == 'n':
				if key in repository:
					print('Reference already loaded.')
					# Don't delete here, because it is likely a wrong key
					return False
				#
				bib = edit_bibtex_manually('', key)
				return add_article_recur_C(key, bib, '', filepath, file_exists, text, repository, config)
			#
			else: key = ''
		#
		if not len(key): return False
		return add_article_recur_A(key, filepath, file_exists, text, repository, config)
	#
	# Check if already present
	if key in repository:
		print('Reference already loaded.')
		if file_exists:
			ui = input('Delete file? (Yes=y, No) ')
			if ui == 'y': os.remove(filepath)
		#
		return False
	#
	# Get the bib
	bib, url = get_bib(key)
	question = (
		'Could not retrieve bibtex for key {}, file {}'
		', retry? (Skip=s, Manually=m, Retry=r, New key) '.format(key, filepath)
	)
	while not len(bib):
		ui = input(question).strip().lower()
		if ui == 's': return None, None
		elif ui == 'm':
			bib = edit_bibtex_manually(bib, key)
			continue
		#
		elif ui == 'r': continue
		else: return add_article_recur_A(ui, filepath, file_exists, repository, config)
	#
	return add_article_recur_B(key, bib, url, filepath, file_exists, text, repository, config)
#

def add_article_recur_B(key, bib, url, filepath, file_exists, text, repository, config):
	"""
		Does bibtex match?
	"""
	global viewer_proc
	clear_screen()
	ui = input(
		'Found this bibtex:\n\n{}\n\nDoes it match the reference? '
		'(Skip=s, Edit=e, New key=..., Yes): '.format(bib)
	).strip().lower()
	if not len(ui): return add_article_recur_C(key, bib, url, filepath, file_exists, text, repository, config)
	elif ui == 's': return False
	elif ui == 'e':
		bib = edit_bibtex_manually(bib, key)
		return add_article_recur_C(key, bib, url, filepath, file_exists, text, repository, config)
	#
	else: return add_article_recur_A(ui, filepath, file_exists, text, repository, config) # New key entered
#

def add_article_recur_C(key, bib, url, filepath, file_exists, text, repository, config):
	"""
		Check validity of bib and finalise
	"""
	global viewer_proc
	# Check for non-asciis
	if is_non_ascii(bib):
		# Change bib to something more reasonable
		bib = unicode_to_latex(
			bib,
			non_ascii_only=True,
			replacement_latex_protection='braces-all',
			unknown_char_warning=False
		)
		question = (
			'Received invalid bibtex for {}, tried to fix it:\n\n{}\n\n'
			'Adjust manually? (Skip=s, Edit=e, All good) '
		).format(filepath, bib)
		clear_screen()
		ui = input(question).strip().lower()
		if ui == 's': return False
		elif ui == 'e':
			bib = edit_bibtex_manually(bib, key)
			return add_article_recur_C(bib, filepath, file_exists, text, repository, config)
		#
	#
	duck = finalise_citation(bib)
	if not duck:
		print("Could not parse bibtex.")
		return False
	#
	bib, target_dir, target_filename = duck

	# Download file if required
	if filepath == '-':
		website = requests.get(url)
		while website.ok:
			ui = input('Could not load pdf from arXiv {} (Skip=s, Retry): '.format(url))
			if ui == 's': return False
			website = requests.get(url)
		#
		handle, filepath = tempfile.mkstemp()
		with open(handle, 'wb') as f:
			f.write(website.content)
		#
	#

	# Get pdf text if not already done (when searching a key)
	if not len(text): text = get_text(filepath)

	# Save changes
	write_celsus_file(target_filename, key, bib, text)

	# Add to repo
	repository[key] = None # No entry needed, only key

	# Generate target path
	if not os.path.exists(target_dir): os.makedirs(target_dir)
	# Move file
	try: shutil.move(filepath, target_filename)
	except:
		print('Could not move file {} to {}.'.format(filepath, target_filename))
		return False
	#
	return True
#

def add_article(key, filepath, repository, config):
	# Check file
	must_download_file = (filepath == '-')
	file_exists = ((not must_download_file) and os.path.exists(filepath))
	if (not must_download_file) and (not file_exists):
		print('File not found {}.'.format(filepath))
		return False
	#
	# Is it pdf?
	if file_exists and not filepath.lower().endswith('.pdf'):
		print('Only pdf files are supported.')
		return False
	#
	result = add_article_recur_A(key, filepath, file_exists, '', repository, config)
	if is_alive(viewer_proc): viewer_proc.terminate()
	return result
#





# Execute commands
config = get_config()
if args.command == 'use':
	# Create the target directory if non-existent
	path = os.path.abspath(args.path)
	if not os.path.exists(path): os.makedirs(path)
	config['active'] = path
	write_config(config)
#
elif args.command == 'add':
	# Check args
	if args.from_dir is None:
		files_and_keys = args.refs
		l = len(files_and_keys)
		if l < 2 or l % 2 != 0:
			raise Exception('Even number of more than two arguments expected.')
		#
	#
	else:
		# Generate list of pdf files
		if not os.path.exists(args.from_dir): raise Exception('Directory does not exist.')
		files_and_keys = []
		for root, dirs, files in os.walk(args.from_dir):
			for filename in files:
				if filename.endswith('.pdf'):
					filepath = os.path.join(root, filename)
					files_and_keys.extend((filepath, '-'))
				#
			#
		#
		l = len(files_and_keys)
	#

	# Get repo and paths
	repository, path = get_active_repository(config, load=ONLY_KEY)

	# Iterate arguments
	viewer_proc = None
	for i in range(0, l, 2):
		filepath, key = files_and_keys[i:i+2]
		if add_article(key, filepath, repository, config): continue
		print('Failed to add {}.\n\n'.format(filepath))
	#
#
elif args.command == 'list':
	# Load keys to search among from file
	if args.include is not None:
		load = []
		for f in args.include:
			if not os.path.isfile(f):
				raise Exception('File {} not found.'.format(f))
			#
			with open(f, 'r') as f:
				keys_to_use = f.read().strip().split('\n')
			#
			load.extend(key.lower() for key in keys_to_use)
		#
	#
	else: load = BIB_AND_CONTENT if args.deep else BIB

	# Get keys to exclude
	if args.exclude is not None:
		keys_to_exclude = []
		for f in args.exclude:
			if not os.path.isfile(f):
				raise Exception('File {} not found.'.format(f))
			#
			with open(f, 'r') as f:
				keys_to_exclude.extend(key.lower() for key in f.read().strip().split('\n'))
			#
		#
	#
	else: keys_to_exclude = []

	# Get keywords in upper and lower case (for key)
	keywords = args.keywords
	keywords_lower = tuple(k.lower() for k in args.keywords)

	if not args.deep:
		# Get repo
		repository, root_path = get_active_repository(config, load, keys_to_exclude)

		# Set up format string for printing info
		fmt_str = []
		if args.key: fmt_str.append('{key}\n')
		if args.file: fmt_str.append('{file}\n')
		if not args.nobib:
			fmt_str.append('{bib}')
		#
		else:
			fmt_str[-1] = fmt_str[-1][:-1] # Cut off last newline (included in print() anyway)
		#
		fmt_str = ''.join(fmt_str)
		# Set up mechanism to remember which files to open if wanted
		to_open = []
		remember_file = (
			(lambda file: to_open.append(file))
			if args.open else
			(lambda file: None)
		)
		# Search and print
		for (key, (file, bib, _)) in repository.items():
			if all((k in bib or kl == key) for (k, kl) in zip(keywords, keywords_lower)):
				file = os.path.join(root_path, file)
				print(fmt_str.format(key=key, file=file, bib=bib))
				remember_file(file)
			#
		#
		if not args.open: exit(0)
		# Open files
		number_of_files = len(to_open)
		if number_of_files > 5:
			if input(
				'Open {} files? (Yes=y, No) '.format(number_of_files)
			).strip().lower() != 'y':
				exit(0)
			#
		#
		for file in to_open:
			open_viewer(file, config)
		#
	#
	else:
		# Get repo
		repository, root_path = get_active_repository(config, load, keys_to_exclude)

		# Search
		found = []
		for (key, (_, bib, content)) in repository.items():
			search_string = bib + '\n' + content
			if all((k in search_string or kl == key) for (k, kl) in zip(keywords, keywords_lower)):
				found.append(key)
				print(bib + '\n')
			#
		#

		# Open files
		number_of_files = len(found)
		if number_of_files > 5:
			if input(
				'Open {} files one after another? (Yes=y, No) '.format(number_of_files)
			).strip().lower() != 'y':
				exit(0)
			#
		#
		collected = []
		for key in found:
			viewer_proc = open_viewer(os.path.join(root_path, repository[key][0]), config)
			ui = input('Add reference to list? (Stop=s, Yes=y, No) ').strip().lower()
			if ui == 's':
				if is_alive(viewer_proc): viewer_proc.terminate()
				break
			#
			elif ui == 'y':
				collected.append(key)
			#
			if is_alive(viewer_proc): viewer_proc.terminate()
		#
		collected = '\n'.join(collected)

		# Output
		if len(collected) == 0: exit(0)
		ui = input('Write keys to file? (Create/Append to file=FILENAME, Print to stdout) ').strip()
		if len(ui):
			with open(ui, 'a') as f: f.write(collected)
		#
		else: print(collected)
	#
#
elif args.command == 'remove':
	keys = args.keys
	args_open = not args.noopen

	# Load the repo
	repository, root_path = get_active_repository(config, load=keys)

	# Function to (re)move file
	wd = os.getcwd()
	remove_entry = (
		lambda path: shutil.move(path, os.path.join(wd, os.path.split(path)[1]))
		if args.move else
		lambda path: os.remove(path)
	)
	
	# Iterate given keys
	for key in keys:
		# Check if key there, get path
		if key not in repository:
			print('Key {} not in repository.'.format(key))
			continue
		#
		path, bib, _ = repository[key]
		path = os.path.join(root_path, path)
		# Ask for user input
		if args_open: viewer_proc = open_viewer(path, config)
		else: viewer_proc = None
		ui = input('Remove this entry?\n\n{}\n\n(Yes=y, No) '.format(bib)).strip().lower()
		if ui != 'y': continue
		# Remove if necessary
		remove_entry(path)
		os.remove(path + '.celsus')
		# Close viewer if still open
		if is_alive(viewer_proc): viewer_proc.terminate()
	#
#
elif args.command == 'config':
	if args.editor is not None: config['editor'] = args.editor
	if args.viewer is not None: config['viewer'] = args.viewer
	write_config(config)
#

